(in-package #:info.isoraqathedh.betza.board)

(defvar *light-colour* #(255 255 213))
(defvar *dark-colour*  #(99 139 118))
(defvar *edge-colour*  #(131 57 0))
(defvar *square-size*  50)

(defun piece-image (name)
  (merge-pathnames (make-pathname :name name :type "png")
                   (asdf:system-relative-pathname 'betza "alfaerie/")))

(defclass board-image ()
  ((margin :initarg :margin
           :reader margin)
   (square-size :reader square-size)
   (x :initarg :x
      :reader board-x)
   (y :initarg :y
      :reader board-y)
   (image-array :accessor image-array))
  (:default-initargs
   :x 11 :y 11 :margin 5))

(defmethod initialize-instance :after ((instance board-image) &key x y margin)
  (setf (image-array instance)
        (let* ((height (+ (* margin 2) (* y *square-size*)))
               (width  (+ (* margin 2) (* x *square-size*))))
          (let ((img (png:make-image height width 3)))
            (dotimes (h height)
              (dotimes (w width)
                (let ((fill-colour
                        (cond ((or (< w margin) (<= (- width margin) w)
                                   (< h margin) (<= (- height margin) h))
                               *edge-colour*)
                              ((evenp (+ (floor (- w margin) *square-size*)
                                         (floor (- h margin) *square-size*)))
                               *light-colour*)
                              ((oddp (+ (floor (- w margin) *square-size*)
                                        (floor (- h margin) *square-size*)))
                               *dark-colour*)
                              (t (vector 0 0 0)))))
                  (dotimes (i 3)
                    (setf (aref img h w i) (aref fill-colour i))))))
            img))))

(defgeneric dump-board (image to)
  (:method ((board-image board-image) (to null))
    (let ((process (uiop:launch-program (list "feh" "-") :input :stream)))
      (png:encode (image-array board-image) (uiop:process-info-input process))
      (uiop:close-streams process)
      (uiop:wait-process process))))

(defgeneric place-piece (board-image piece-image x y)
  (:method ((board board-image) (piece-image pathname) (x number) (y number))
    (let ((piece (with-open-file (s piece-image :element-type '(unsigned-byte 8))
                   (png:decode s))))
      (dotimes (h (png:image-height piece))
        (dotimes (w (png:image-width piece))
          (unless (= #x00FF00
                     (+ (* #x010000 (aref piece h w 0))
                        (* #x000100 (aref piece h w 1))
                        (aref piece h w 2)))
            (dotimes (i 3)
              (setf (aref (image-array board)
                          (+ (margin board)
                             (* (floor (- (/ (board-y board) 2) y)) *square-size*)
                             h)
                          (+ (margin board)
                             (* (floor (+ (/ (board-x board) 2) x)) *square-size*)
                             w)
                          i)
                    (aref piece h w i))))))))
  (:method ((board board-image) (piece-image null) (x number) (y number))
    (let ((col (cond ((evenp (+ x y)) *light-colour*)
                     ((oddp (+ x y)) *dark-colour*)
                     (t (vector 0 0 0)))))
     (dotimes (h *square-size*)
       (dotimes (w *square-size*)
         (dotimes (i 3)
           (setf (aref (image-array board)
                       (+ (margin board)
                          (* (floor (- (/ (board-y board) 2) y)) *square-size*)
                          h)
                       (+ (margin board)
                          (* (floor (+ (/ (board-x board) 2) x)) *square-size*)
                          w)
                       i)
                 (aref col i))))))))
